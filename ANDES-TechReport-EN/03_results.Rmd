# Results

## Technical implementation of design goals

\gls{andes} system architecture differs greatly from the legacy entry systems that it succeeds. \gls{andes} offers a centralised data entry *service* that is accessed with client devices. Thus, one does not install the \gls{andes} software on input stations (e.g., laptop, tablet, ...), rather \gls{andes} is installed on a server and is accessed via a web browser. This means any device that supports modern web browsers (Google Chrome, Apple Safari, Microsoft Edge, Firefox, etc.) can potentially be used as input stations. This also means multiple stations can simultaneously enter data into the same \gls{andes} instance.

The [Django Web Framework](https://www.djangoproject.com/) was selected for the backend of this application due to its modularized nature; virtually all aspects of the programming framework can be decoupled. Furthermore, the Django framework is written in pure Python language; an open-source, generalized object-orientated programming language that is popular for use in data-heavy applications. While web applications are most often used over a network, the Django library comes with a development web-server that permits users to serve and use the application locally. In this scenario, a single computer acts simultaneously as server and client. While there are important limitations to the use of the Django development web-server in a full-scale production environment, this configuration is adequate for stand-alone use-cases.

Figure \@ref(fig:arch) shows the basic system architecture of \gls{andes}. \gls{andes} itself is a Django web framework project. It hosts multiple applications that are presented in more details below. The web framework is composed of a backend \gls{REST-API} and a frontend. Django uses an \gls{ORM} to handle the data layer, and drivers exist for a variety of modern relational database management systems (i.e., PostgreSQL, MariaDB, MySQL, Oracle, SQLite, etc.). Django's web frontend can contain reactive components implemented in VUEjs.

This client-server separation lends itself nicely to be adaptable to new requirements. One can potentially expand upon the *system* with minimal changes to \gls{andes} by interacting directly with its exposed \gls{REST-API}. For example, an imaging system can be aware of current GPS coordinates or current \gls{Set} / \gls{Station}. Photos or videos acquired by such an imaging system could automatically append these as metadata, or even add media identifiers directly to the database as they are captured.

The simplified \gls{ERD} of relevant \gls{andes} components is on Figure \@ref(fig:ERD).

### Flexibility, scalability and reliability

The architecture used by \gls{andes} creates networking requirements that were not previously present in the \gls{ese} and \gls{mrr}. The server and the client devices must be connected to the same network. The network does not need to have access to the wide area network (i.e., internet) connection. As long as they are connected to the same \gls{lan}, they can be configured for work together. This suits the networking environment on board remote vessels that can have sporadic connection failures with the wide area network.

Most modern vessels will already provide the minimum necessary networking infrastructure necessary for system deployment where connectivity between a dry laboratory, a wet laboratory and the ship's wheelhouse are necessary. In the case where it doesn't, this requirement can be met relatively easily using inexpensive consumer-grade networking equipment (wireless router, switch, etc.). However, installing as ad-hoc network for scientific needs in a vessel may lead to code violations and we urge \gls{andes} users to collaborate with vessel management body like the \gls{CCG} or chartering authority.

\gls{andes} provides access to its different components differently based on the credentials of users. While the chief scientist can change sampling requirements for the mission, other users won't.


### Version Control / Source Control

It was decided to use [Git](https://git-scm.com/) as the \gls{vcs} for this project due to the fact that it is both widespread in use and open-sourced. The remote repository for this project is currently hosted on the [Gulf Science organizational GitHub account](https://github.com/dfo-gulf-science). The project is additionally making use of GitHub infrastructure including, pull requests, issue management (e.g., bugs, feature requests and general enhancement requests), security alerts and a user-driven Wiki.

### Unit testing

For \gls{andes} development, we use a mixture of test-driven development for critical components of the application, and are also continually adding unit tests for more user-specific components. Using the built-in Python / Django testing framework, this strikes a middle ground between the above two approaches. While the goal is not to implement test-driven development for the application, the use of unit tests is highly encouraged, especially to back up the core functionality of the application.

### User-defined protocols

### User Interface

The frontend of the application is built in \gls{html5}, \gls{javascript} and \gls{CSS}. Most users will be familiar with the flow and functionality of a web browser and will be comfortable navigating and entering data into a website. Facilitated by the Django model and form classes, all controls (i.e., fields) on the website contain verbose descriptions and help text. The [Bootstap v5.0](https://getbootstrap.com/docs/5.0/getting-started/introduction/) \gls{CSS} and \gls{javascript} libraries were utilized in order to give the application a sleek, modern look and to ensure compatibility with different types of devices (e.g., personal computers, tablets and mobile devices). The Bootstrap library also provides palatable styles for displaying help text in the form of popovers and tooltips.

### Reactivity

The [Django REST framework](https://www.django-rest-framework.org/) was used to construct the WebAPI component of the application. The project takes a hybrid approach, combining the use of standard Django views and [Vue.js](https://vuejs.org/) frontend applications embedded in the templates. The latter were built to avoid the need for constantly reloading webpages and to optimize the flow of traffic across the network. Reactive javascript frontend applications also provide a better experience from the point of view of an end-user.

### Multilingualism

The Django framework has excellent support for internationalization and localization, including the translation of text and the formatting of dates, times and numbers. It achieves this using a system of "hooks" used by developers to indicate which parts of the code should be localized. See [Django - Internationalization and localization](https://docs.djangoproject.com/en/4.1/topics/i18n/) for more details on this process. In our application, an end-user can toggle between English and French by simply clicking on a button. In this way, each client can view the application in the language of their choice.

## Usage cases

### Ecosystem survey data entry

This component of \gls{andes} replicates the capabilities of the \gls{ese} for capturing detailed information on length, weight, ageing material, maturity, etc. about fish and invertebrate specimens. The app running on computers in the wet laboratory of the vessel is used for all entry of data related to measurements and observations of marine organisms (Figure \@ref(fig:andes-wetlab1)). The \gls{Ecosystem Survey} application is the main entrypoint that technicians will use to input survey data.

The Shrimp Ecosystem Survey application resulted from the early adoption of \gls{andes} in the Qu√©bec region. The niche workflow requirements of shrimp survey operations justified the creation of its own \gls{andes} module. 

The console to be used by navigation officers is meant to run on a tablet in the bridge of the vessel conducting the survey (Figure \@ref(fig:bridge)). This console contains two separate sections: 1) the Set Card section and 2) the Fishing section. Additionally, a number of events that take place during fishing can be captured in the console. The bridge console also shows the information coming from the trawl mensuration system sensors (Scanmar), which is captured and stored by \gls{andes}.

Part of the task-specific suite of utilities is a forecasting tool that provides real-time prognostics of survey completion targets based on assumed transit speeds and time spent fishing and processing the trawl catches (Figure \@ref(fig:forecast)). This tool provides a useful tool for the chief scientist to evaluate different sampling objectives and survey route. As the conditions change regularly during a survey, this tool links with the set manager to provide an estimate of the amount of time required to complete planned stations. This tool can be used for short-term planning (i.e. a day's worth of sampling) or longer-term planning (i.e. a mission's worth of sampling). 

Another task-specific utility is the completion map which shows what strata have been completed based on target and minimum number of sets per stratum. This map provides the chief scientist with a clear visual depiction of what has been accomplished, and what remains to be accomplished, during the survey. The number of sets conducted in each stratum is compared to the minimum and target number of sets per stratum to determine the colour that each stratum will appear in the progress map (Figure \@ref(fig:progress)).

The dashboard utility is meant to obtain a summary of the cruise, it includes the current position and speed of the vessel, the list of the most recent catches in the wet laboratory, as well as running totals of specimens captured (Figure \@ref(fig:dashboard)).

### Oceanographic metadata collection

The Oceanographic module is a stand-alone component of the application that is capable of being deployed independently of the Ecosystem Survey module.

The oceanography data collection is handled by a separate app that is used in the deployment of the rosette and the processing of water samples obtained at different depths  (Figure \@ref(fig:oceanography)).

### Commercial port sampling

\gls{andes} was adapted to support port sampling activities where technicians obtain length frequency samples from commercial fishing activities. To facilitate deployment, the port sampling app of \gls{andes} is deployed on field tablets with a custom interface that is suitable for use on boats, outdoor and in inclement weather conditions (Figure \@ref(fig:portsampling1)).



<!-- SCRATCH!! -->


<!-- server-client -->
The architecture of the Andes data entry system differs from that of its predecessor. The Andes application and its associated services are centralised on one or several servers. The main services include: 1) a web-service for service handling HTTP requests and responses; 2) a database service for storing data associated with the application; 3) a file-sharing service for handling the storage of backups and related files; 4) a printing service used for printing out specimen labels; and 5) a message-brokering service for handling asynchronous tasks. Client devices, such as data-entry workstations, no longer require the installation of anything more than a modern web browser; i.e., one that is capable of supporting HTML5 and ECMAScript (Javascript) 2016. Accordingly, this increases the range of devices and operating systems that may be used for accessing the application. For instance, the switch to using Andes has allowed the integration of mobile phones, tablets and linux workstations into the data entry workflow. Finally, the new architecture simplifies and further enables simultaneous data entry and acquisition across multiple clients.

<!-- web framework -->
Figure \@ref(fig:arch) shows the basic system architecture of Andes.
The Andes application itself is a Django web framework project.
It contains multiple Django apps (i.e., sub-components) that are explored in this document.
In addition to the standard templates which are used to render HTML webpages to end-users, the web framework also contains an elaborate \gls{REST-API} component.
Django uses an \gls{ORM} to handle the data layer, and drivers exist for a variety of modern relational database management systems (i.e., PostgreSQL, MariaDB, MySQL, Oracle, SQLite, etc.). Django's web frontend can contain reactive components implemented in VUEjs.